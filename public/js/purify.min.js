(() => {
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };

  // <stdin>
  var require_stdin = __commonJS({
    "<stdin>"(exports, module) {
      !function(e, t) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).DOMPurify = t();
      }(exports, function() {
        "use strict";
        const { entries: e, setPrototypeOf: t, isFrozen: n, getPrototypeOf: o, getOwnPropertyDescriptor: r } = Object;
        let { freeze: i, seal: a, create: l } = Object, { apply: c, construct: s } = "undefined" != typeof Reflect && Reflect;
        i || (i = function(e2) {
          return e2;
        }), a || (a = function(e2) {
          return e2;
        }), c || (c = function(e2, t2) {
          for (var n2 = arguments.length, o2 = new Array(n2 > 2 ? n2 - 2 : 0), r2 = 2; r2 < n2; r2++) o2[r2 - 2] = arguments[r2];
          return e2.apply(t2, o2);
        }), s || (s = function(e2) {
          for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), o2 = 1; o2 < t2; o2++) n2[o2 - 1] = arguments[o2];
          return new e2(...n2);
        });
        const u = D(Array.prototype.forEach), m = D(Array.prototype.lastIndexOf), p = D(Array.prototype.pop), f = D(Array.prototype.push), d = D(Array.prototype.splice), h = D(String.prototype.toLowerCase), g = D(String.prototype.toString), T = D(String.prototype.match), y = D(String.prototype.replace), E = D(String.prototype.indexOf), A = D(String.prototype.trim), _ = D(Object.prototype.hasOwnProperty), b = D(RegExp.prototype.test), S = (N = TypeError, function() {
          for (var e2 = arguments.length, t2 = new Array(e2), n2 = 0; n2 < e2; n2++) t2[n2] = arguments[n2];
          return s(N, t2);
        });
        var N;
        function D(e2) {
          return function(t2) {
            t2 instanceof RegExp && (t2.lastIndex = 0);
            for (var n2 = arguments.length, o2 = new Array(n2 > 1 ? n2 - 1 : 0), r2 = 1; r2 < n2; r2++) o2[r2 - 1] = arguments[r2];
            return c(e2, t2, o2);
          };
        }
        function R(e2, o2) {
          let r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : h;
          t && t(e2, null);
          let i2 = o2.length;
          for (; i2--; ) {
            let t2 = o2[i2];
            if ("string" == typeof t2) {
              const e3 = r2(t2);
              e3 !== t2 && (n(o2) || (o2[i2] = e3), t2 = e3);
            }
            e2[t2] = true;
          }
          return e2;
        }
        function w(e2) {
          for (let t2 = 0; t2 < e2.length; t2++) {
            _(e2, t2) || (e2[t2] = null);
          }
          return e2;
        }
        function C(t2) {
          const n2 = l(null);
          for (const [o2, r2] of e(t2)) {
            _(t2, o2) && (Array.isArray(r2) ? n2[o2] = w(r2) : r2 && "object" == typeof r2 && r2.constructor === Object ? n2[o2] = C(r2) : n2[o2] = r2);
          }
          return n2;
        }
        function O(e2, t2) {
          for (; null !== e2; ) {
            const n2 = r(e2, t2);
            if (n2) {
              if (n2.get) return D(n2.get);
              if ("function" == typeof n2.value) return D(n2.value);
            }
            e2 = o(e2);
          }
          return function() {
            return null;
          };
        }
        const v = i(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), x = i(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "enterkeyhint", "exportparts", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "inputmode", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "part", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), L = i(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), k = i(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), I = i(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), M = i(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), U = i(["#text"]), z = i(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "exportparts", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inert", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "part", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "slot", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), P = i(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "mask-type", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), F = i(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), H = i(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), B = a(/\{\{[\w\W]*|[\w\W]*\}\}/gm), G = a(/<%[\w\W]*|[\w\W]*%>/gm), W = a(/\$\{[\w\W]*/gm), Y = a(/^data-[\-\w.\u00B7-\uFFFF]+$/), j = a(/^aria-[\-\w]+$/), X = a(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i), q = a(/^(?:\w+script|data):/i), $ = a(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), K = a(/^html$/i), V = a(/^[a-z][.\w]*(-[.\w]+)+$/i);
        var Z = Object.freeze({ __proto__: null, ARIA_ATTR: j, ATTR_WHITESPACE: $, CUSTOM_ELEMENT: V, DATA_ATTR: Y, DOCTYPE_NAME: K, ERB_EXPR: G, IS_ALLOWED_URI: X, IS_SCRIPT_OR_DATA: q, MUSTACHE_EXPR: B, TMPLIT_EXPR: W });
        const J = 1, Q = 3, ee = 7, te = 8, ne = 9, oe = function() {
          return "undefined" == typeof window ? null : window;
        };
        var re = function t2() {
          let n2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : oe();
          const o2 = (e2) => t2(e2);
          if (o2.version = "3.3.0", o2.removed = [], !n2 || !n2.document || n2.document.nodeType !== ne || !n2.Element) return o2.isSupported = false, o2;
          let { document: r2 } = n2;
          const a2 = r2, c2 = a2.currentScript, { DocumentFragment: s2, HTMLTemplateElement: N2, Node: D2, Element: w2, NodeFilter: B2, NamedNodeMap: G2 = n2.NamedNodeMap || n2.MozNamedAttrMap, HTMLFormElement: W2, DOMParser: Y2, trustedTypes: j2 } = n2, q2 = w2.prototype, $2 = O(q2, "cloneNode"), V2 = O(q2, "remove"), re2 = O(q2, "nextSibling"), ie = O(q2, "childNodes"), ae = O(q2, "parentNode");
          if ("function" == typeof N2) {
            const e2 = r2.createElement("template");
            e2.content && e2.content.ownerDocument && (r2 = e2.content.ownerDocument);
          }
          let le, ce = "";
          const { implementation: se, createNodeIterator: ue, createDocumentFragment: me, getElementsByTagName: pe } = r2, { importNode: fe } = a2;
          let de = { afterSanitizeAttributes: [], afterSanitizeElements: [], afterSanitizeShadowDOM: [], beforeSanitizeAttributes: [], beforeSanitizeElements: [], beforeSanitizeShadowDOM: [], uponSanitizeAttribute: [], uponSanitizeElement: [], uponSanitizeShadowNode: [] };
          o2.isSupported = "function" == typeof e && "function" == typeof ae && se && void 0 !== se.createHTMLDocument;
          const { MUSTACHE_EXPR: he, ERB_EXPR: ge, TMPLIT_EXPR: Te, DATA_ATTR: ye, ARIA_ATTR: Ee, IS_SCRIPT_OR_DATA: Ae, ATTR_WHITESPACE: _e, CUSTOM_ELEMENT: be } = Z;
          let { IS_ALLOWED_URI: Se } = Z, Ne = null;
          const De = R({}, [...v, ...x, ...L, ...I, ...U]);
          let Re = null;
          const we = R({}, [...z, ...P, ...F, ...H]);
          let Ce = Object.seal(l(null, { tagNameCheck: { writable: true, configurable: false, enumerable: true, value: null }, attributeNameCheck: { writable: true, configurable: false, enumerable: true, value: null }, allowCustomizedBuiltInElements: { writable: true, configurable: false, enumerable: true, value: false } })), Oe = null, ve = null;
          const xe = Object.seal(l(null, { tagCheck: { writable: true, configurable: false, enumerable: true, value: null }, attributeCheck: { writable: true, configurable: false, enumerable: true, value: null } }));
          let Le = true, ke = true, Ie = false, Me = true, Ue = false, ze = true, Pe = false, Fe = false, He = false, Be = false, Ge = false, We = false, Ye = true, je = false, Xe = true, qe = false, $e = {}, Ke = null;
          const Ve = R({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
          let Ze = null;
          const Je = R({}, ["audio", "video", "img", "source", "image", "track"]);
          let Qe = null;
          const et = R({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), tt = "http://www.w3.org/1998/Math/MathML", nt = "http://www.w3.org/2000/svg", ot = "http://www.w3.org/1999/xhtml";
          let rt = ot, it = false, at = null;
          const lt = R({}, [tt, nt, ot], g);
          let ct = R({}, ["mi", "mo", "mn", "ms", "mtext"]), st = R({}, ["annotation-xml"]);
          const ut = R({}, ["title", "style", "font", "a", "script"]);
          let mt = null;
          const pt = ["application/xhtml+xml", "text/html"];
          let ft = null, dt = null;
          const ht = r2.createElement("form"), gt = function(e2) {
            return e2 instanceof RegExp || e2 instanceof Function;
          }, Tt = function() {
            let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (!dt || dt !== e2) {
              if (e2 && "object" == typeof e2 || (e2 = {}), e2 = C(e2), mt = -1 === pt.indexOf(e2.PARSER_MEDIA_TYPE) ? "text/html" : e2.PARSER_MEDIA_TYPE, ft = "application/xhtml+xml" === mt ? g : h, Ne = _(e2, "ALLOWED_TAGS") ? R({}, e2.ALLOWED_TAGS, ft) : De, Re = _(e2, "ALLOWED_ATTR") ? R({}, e2.ALLOWED_ATTR, ft) : we, at = _(e2, "ALLOWED_NAMESPACES") ? R({}, e2.ALLOWED_NAMESPACES, g) : lt, Qe = _(e2, "ADD_URI_SAFE_ATTR") ? R(C(et), e2.ADD_URI_SAFE_ATTR, ft) : et, Ze = _(e2, "ADD_DATA_URI_TAGS") ? R(C(Je), e2.ADD_DATA_URI_TAGS, ft) : Je, Ke = _(e2, "FORBID_CONTENTS") ? R({}, e2.FORBID_CONTENTS, ft) : Ve, Oe = _(e2, "FORBID_TAGS") ? R({}, e2.FORBID_TAGS, ft) : C({}), ve = _(e2, "FORBID_ATTR") ? R({}, e2.FORBID_ATTR, ft) : C({}), $e = !!_(e2, "USE_PROFILES") && e2.USE_PROFILES, Le = false !== e2.ALLOW_ARIA_ATTR, ke = false !== e2.ALLOW_DATA_ATTR, Ie = e2.ALLOW_UNKNOWN_PROTOCOLS || false, Me = false !== e2.ALLOW_SELF_CLOSE_IN_ATTR, Ue = e2.SAFE_FOR_TEMPLATES || false, ze = false !== e2.SAFE_FOR_XML, Pe = e2.WHOLE_DOCUMENT || false, Be = e2.RETURN_DOM || false, Ge = e2.RETURN_DOM_FRAGMENT || false, We = e2.RETURN_TRUSTED_TYPE || false, He = e2.FORCE_BODY || false, Ye = false !== e2.SANITIZE_DOM, je = e2.SANITIZE_NAMED_PROPS || false, Xe = false !== e2.KEEP_CONTENT, qe = e2.IN_PLACE || false, Se = e2.ALLOWED_URI_REGEXP || X, rt = e2.NAMESPACE || ot, ct = e2.MATHML_TEXT_INTEGRATION_POINTS || ct, st = e2.HTML_INTEGRATION_POINTS || st, Ce = e2.CUSTOM_ELEMENT_HANDLING || {}, e2.CUSTOM_ELEMENT_HANDLING && gt(e2.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Ce.tagNameCheck = e2.CUSTOM_ELEMENT_HANDLING.tagNameCheck), e2.CUSTOM_ELEMENT_HANDLING && gt(e2.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Ce.attributeNameCheck = e2.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), e2.CUSTOM_ELEMENT_HANDLING && "boolean" == typeof e2.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (Ce.allowCustomizedBuiltInElements = e2.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Ue && (ke = false), Ge && (Be = true), $e && (Ne = R({}, U), Re = [], true === $e.html && (R(Ne, v), R(Re, z)), true === $e.svg && (R(Ne, x), R(Re, P), R(Re, H)), true === $e.svgFilters && (R(Ne, L), R(Re, P), R(Re, H)), true === $e.mathMl && (R(Ne, I), R(Re, F), R(Re, H))), e2.ADD_TAGS && ("function" == typeof e2.ADD_TAGS ? xe.tagCheck = e2.ADD_TAGS : (Ne === De && (Ne = C(Ne)), R(Ne, e2.ADD_TAGS, ft))), e2.ADD_ATTR && ("function" == typeof e2.ADD_ATTR ? xe.attributeCheck = e2.ADD_ATTR : (Re === we && (Re = C(Re)), R(Re, e2.ADD_ATTR, ft))), e2.ADD_URI_SAFE_ATTR && R(Qe, e2.ADD_URI_SAFE_ATTR, ft), e2.FORBID_CONTENTS && (Ke === Ve && (Ke = C(Ke)), R(Ke, e2.FORBID_CONTENTS, ft)), e2.ADD_FORBID_CONTENTS && (Ke === Ve && (Ke = C(Ke)), R(Ke, e2.ADD_FORBID_CONTENTS, ft)), Xe && (Ne["#text"] = true), Pe && R(Ne, ["html", "head", "body"]), Ne.table && (R(Ne, ["tbody"]), delete Oe.tbody), e2.TRUSTED_TYPES_POLICY) {
                if ("function" != typeof e2.TRUSTED_TYPES_POLICY.createHTML) throw S('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
                if ("function" != typeof e2.TRUSTED_TYPES_POLICY.createScriptURL) throw S('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
                le = e2.TRUSTED_TYPES_POLICY, ce = le.createHTML("");
              } else void 0 === le && (le = function(e3, t3) {
                if ("object" != typeof e3 || "function" != typeof e3.createPolicy) return null;
                let n3 = null;
                const o3 = "data-tt-policy-suffix";
                t3 && t3.hasAttribute(o3) && (n3 = t3.getAttribute(o3));
                const r3 = "dompurify" + (n3 ? "#" + n3 : "");
                try {
                  return e3.createPolicy(r3, { createHTML: (e4) => e4, createScriptURL: (e4) => e4 });
                } catch (e4) {
                  return console.warn("TrustedTypes policy " + r3 + " could not be created."), null;
                }
              }(j2, c2)), null !== le && "string" == typeof ce && (ce = le.createHTML(""));
              i && i(e2), dt = e2;
            }
          }, yt = R({}, [...x, ...L, ...k]), Et = R({}, [...I, ...M]), At = function(e2) {
            f(o2.removed, { element: e2 });
            try {
              ae(e2).removeChild(e2);
            } catch (t3) {
              V2(e2);
            }
          }, _t = function(e2, t3) {
            try {
              f(o2.removed, { attribute: t3.getAttributeNode(e2), from: t3 });
            } catch (e3) {
              f(o2.removed, { attribute: null, from: t3 });
            }
            if (t3.removeAttribute(e2), "is" === e2) if (Be || Ge) try {
              At(t3);
            } catch (e3) {
            }
            else try {
              t3.setAttribute(e2, "");
            } catch (e3) {
            }
          }, bt = function(e2) {
            let t3 = null, n3 = null;
            if (He) e2 = "<remove></remove>" + e2;
            else {
              const t4 = T(e2, /^[\r\n\t ]+/);
              n3 = t4 && t4[0];
            }
            "application/xhtml+xml" === mt && rt === ot && (e2 = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + e2 + "</body></html>");
            const o3 = le ? le.createHTML(e2) : e2;
            if (rt === ot) try {
              t3 = new Y2().parseFromString(o3, mt);
            } catch (e3) {
            }
            if (!t3 || !t3.documentElement) {
              t3 = se.createDocument(rt, "template", null);
              try {
                t3.documentElement.innerHTML = it ? ce : o3;
              } catch (e3) {
              }
            }
            const i2 = t3.body || t3.documentElement;
            return e2 && n3 && i2.insertBefore(r2.createTextNode(n3), i2.childNodes[0] || null), rt === ot ? pe.call(t3, Pe ? "html" : "body")[0] : Pe ? t3.documentElement : i2;
          }, St = function(e2) {
            return ue.call(e2.ownerDocument || e2, e2, B2.SHOW_ELEMENT | B2.SHOW_COMMENT | B2.SHOW_TEXT | B2.SHOW_PROCESSING_INSTRUCTION | B2.SHOW_CDATA_SECTION, null);
          }, Nt = function(e2) {
            return e2 instanceof W2 && ("string" != typeof e2.nodeName || "string" != typeof e2.textContent || "function" != typeof e2.removeChild || !(e2.attributes instanceof G2) || "function" != typeof e2.removeAttribute || "function" != typeof e2.setAttribute || "string" != typeof e2.namespaceURI || "function" != typeof e2.insertBefore || "function" != typeof e2.hasChildNodes);
          }, Dt = function(e2) {
            return "function" == typeof D2 && e2 instanceof D2;
          };
          function Rt(e2, t3, n3) {
            u(e2, (e3) => {
              e3.call(o2, t3, n3, dt);
            });
          }
          const wt = function(e2) {
            let t3 = null;
            if (Rt(de.beforeSanitizeElements, e2, null), Nt(e2)) return At(e2), true;
            const n3 = ft(e2.nodeName);
            if (Rt(de.uponSanitizeElement, e2, { tagName: n3, allowedTags: Ne }), ze && e2.hasChildNodes() && !Dt(e2.firstElementChild) && b(/<[/\w!]/g, e2.innerHTML) && b(/<[/\w!]/g, e2.textContent)) return At(e2), true;
            if (e2.nodeType === ee) return At(e2), true;
            if (ze && e2.nodeType === te && b(/<[/\w]/g, e2.data)) return At(e2), true;
            if (!(xe.tagCheck instanceof Function && xe.tagCheck(n3)) && (!Ne[n3] || Oe[n3])) {
              if (!Oe[n3] && Ot(n3)) {
                if (Ce.tagNameCheck instanceof RegExp && b(Ce.tagNameCheck, n3)) return false;
                if (Ce.tagNameCheck instanceof Function && Ce.tagNameCheck(n3)) return false;
              }
              if (Xe && !Ke[n3]) {
                const t4 = ae(e2) || e2.parentNode, n4 = ie(e2) || e2.childNodes;
                if (n4 && t4) {
                  for (let o3 = n4.length - 1; o3 >= 0; --o3) {
                    const r3 = $2(n4[o3], true);
                    r3.__removalCount = (e2.__removalCount || 0) + 1, t4.insertBefore(r3, re2(e2));
                  }
                }
              }
              return At(e2), true;
            }
            return e2 instanceof w2 && !function(e3) {
              let t4 = ae(e3);
              t4 && t4.tagName || (t4 = { namespaceURI: rt, tagName: "template" });
              const n4 = h(e3.tagName), o3 = h(t4.tagName);
              return !!at[e3.namespaceURI] && (e3.namespaceURI === nt ? t4.namespaceURI === ot ? "svg" === n4 : t4.namespaceURI === tt ? "svg" === n4 && ("annotation-xml" === o3 || ct[o3]) : Boolean(yt[n4]) : e3.namespaceURI === tt ? t4.namespaceURI === ot ? "math" === n4 : t4.namespaceURI === nt ? "math" === n4 && st[o3] : Boolean(Et[n4]) : e3.namespaceURI === ot ? !(t4.namespaceURI === nt && !st[o3]) && !(t4.namespaceURI === tt && !ct[o3]) && !Et[n4] && (ut[n4] || !yt[n4]) : !("application/xhtml+xml" !== mt || !at[e3.namespaceURI]));
            }(e2) ? (At(e2), true) : "noscript" !== n3 && "noembed" !== n3 && "noframes" !== n3 || !b(/<\/no(script|embed|frames)/i, e2.innerHTML) ? (Ue && e2.nodeType === Q && (t3 = e2.textContent, u([he, ge, Te], (e3) => {
              t3 = y(t3, e3, " ");
            }), e2.textContent !== t3 && (f(o2.removed, { element: e2.cloneNode() }), e2.textContent = t3)), Rt(de.afterSanitizeElements, e2, null), false) : (At(e2), true);
          }, Ct = function(e2, t3, n3) {
            if (Ye && ("id" === t3 || "name" === t3) && (n3 in r2 || n3 in ht)) return false;
            if (ke && !ve[t3] && b(ye, t3)) ;
            else if (Le && b(Ee, t3)) ;
            else if (xe.attributeCheck instanceof Function && xe.attributeCheck(t3, e2)) ;
            else if (!Re[t3] || ve[t3]) {
              if (!(Ot(e2) && (Ce.tagNameCheck instanceof RegExp && b(Ce.tagNameCheck, e2) || Ce.tagNameCheck instanceof Function && Ce.tagNameCheck(e2)) && (Ce.attributeNameCheck instanceof RegExp && b(Ce.attributeNameCheck, t3) || Ce.attributeNameCheck instanceof Function && Ce.attributeNameCheck(t3, e2)) || "is" === t3 && Ce.allowCustomizedBuiltInElements && (Ce.tagNameCheck instanceof RegExp && b(Ce.tagNameCheck, n3) || Ce.tagNameCheck instanceof Function && Ce.tagNameCheck(n3)))) return false;
            } else if (Qe[t3]) ;
            else if (b(Se, y(n3, _e, ""))) ;
            else if ("src" !== t3 && "xlink:href" !== t3 && "href" !== t3 || "script" === e2 || 0 !== E(n3, "data:") || !Ze[e2]) {
              if (Ie && !b(Ae, y(n3, _e, ""))) ;
              else if (n3) return false;
            } else ;
            return true;
          }, Ot = function(e2) {
            return "annotation-xml" !== e2 && T(e2, be);
          }, vt = function(e2) {
            Rt(de.beforeSanitizeAttributes, e2, null);
            const { attributes: t3 } = e2;
            if (!t3 || Nt(e2)) return;
            const n3 = { attrName: "", attrValue: "", keepAttr: true, allowedAttributes: Re, forceKeepAttr: void 0 };
            let r3 = t3.length;
            for (; r3--; ) {
              const i2 = t3[r3], { name: a3, namespaceURI: l2, value: c3 } = i2, s3 = ft(a3), m2 = c3;
              let f2 = "value" === a3 ? m2 : A(m2);
              if (n3.attrName = s3, n3.attrValue = f2, n3.keepAttr = true, n3.forceKeepAttr = void 0, Rt(de.uponSanitizeAttribute, e2, n3), f2 = n3.attrValue, !je || "id" !== s3 && "name" !== s3 || (_t(a3, e2), f2 = "user-content-" + f2), ze && b(/((--!?|])>)|<\/(style|title|textarea)/i, f2)) {
                _t(a3, e2);
                continue;
              }
              if ("attributename" === s3 && T(f2, "href")) {
                _t(a3, e2);
                continue;
              }
              if (n3.forceKeepAttr) continue;
              if (!n3.keepAttr) {
                _t(a3, e2);
                continue;
              }
              if (!Me && b(/\/>/i, f2)) {
                _t(a3, e2);
                continue;
              }
              Ue && u([he, ge, Te], (e3) => {
                f2 = y(f2, e3, " ");
              });
              const d2 = ft(e2.nodeName);
              if (Ct(d2, s3, f2)) {
                if (le && "object" == typeof j2 && "function" == typeof j2.getAttributeType) if (l2) ;
                else switch (j2.getAttributeType(d2, s3)) {
                  case "TrustedHTML":
                    f2 = le.createHTML(f2);
                    break;
                  case "TrustedScriptURL":
                    f2 = le.createScriptURL(f2);
                }
                if (f2 !== m2) try {
                  l2 ? e2.setAttributeNS(l2, a3, f2) : e2.setAttribute(a3, f2), Nt(e2) ? At(e2) : p(o2.removed);
                } catch (t4) {
                  _t(a3, e2);
                }
              } else _t(a3, e2);
            }
            Rt(de.afterSanitizeAttributes, e2, null);
          }, xt = function e2(t3) {
            let n3 = null;
            const o3 = St(t3);
            for (Rt(de.beforeSanitizeShadowDOM, t3, null); n3 = o3.nextNode(); ) Rt(de.uponSanitizeShadowNode, n3, null), wt(n3), vt(n3), n3.content instanceof s2 && e2(n3.content);
            Rt(de.afterSanitizeShadowDOM, t3, null);
          };
          return o2.sanitize = function(e2) {
            let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n3 = null, r3 = null, i2 = null, l2 = null;
            if (it = !e2, it && (e2 = "<!-->"), "string" != typeof e2 && !Dt(e2)) {
              if ("function" != typeof e2.toString) throw S("toString is not a function");
              if ("string" != typeof (e2 = e2.toString())) throw S("dirty is not a string, aborting");
            }
            if (!o2.isSupported) return e2;
            if (Fe || Tt(t3), o2.removed = [], "string" == typeof e2 && (qe = false), qe) {
              if (e2.nodeName) {
                const t4 = ft(e2.nodeName);
                if (!Ne[t4] || Oe[t4]) throw S("root node is forbidden and cannot be sanitized in-place");
              }
            } else if (e2 instanceof D2) n3 = bt("<!---->"), r3 = n3.ownerDocument.importNode(e2, true), r3.nodeType === J && "BODY" === r3.nodeName || "HTML" === r3.nodeName ? n3 = r3 : n3.appendChild(r3);
            else {
              if (!Be && !Ue && !Pe && -1 === e2.indexOf("<")) return le && We ? le.createHTML(e2) : e2;
              if (n3 = bt(e2), !n3) return Be ? null : We ? ce : "";
            }
            n3 && He && At(n3.firstChild);
            const c3 = St(qe ? e2 : n3);
            for (; i2 = c3.nextNode(); ) wt(i2), vt(i2), i2.content instanceof s2 && xt(i2.content);
            if (qe) return e2;
            if (Be) {
              if (Ge) for (l2 = me.call(n3.ownerDocument); n3.firstChild; ) l2.appendChild(n3.firstChild);
              else l2 = n3;
              return (Re.shadowroot || Re.shadowrootmode) && (l2 = fe.call(a2, l2, true)), l2;
            }
            let m2 = Pe ? n3.outerHTML : n3.innerHTML;
            return Pe && Ne["!doctype"] && n3.ownerDocument && n3.ownerDocument.doctype && n3.ownerDocument.doctype.name && b(K, n3.ownerDocument.doctype.name) && (m2 = "<!DOCTYPE " + n3.ownerDocument.doctype.name + ">\n" + m2), Ue && u([he, ge, Te], (e3) => {
              m2 = y(m2, e3, " ");
            }), le && We ? le.createHTML(m2) : m2;
          }, o2.setConfig = function() {
            Tt(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}), Fe = true;
          }, o2.clearConfig = function() {
            dt = null, Fe = false;
          }, o2.isValidAttribute = function(e2, t3, n3) {
            dt || Tt({});
            const o3 = ft(e2), r3 = ft(t3);
            return Ct(o3, r3, n3);
          }, o2.addHook = function(e2, t3) {
            "function" == typeof t3 && f(de[e2], t3);
          }, o2.removeHook = function(e2, t3) {
            if (void 0 !== t3) {
              const n3 = m(de[e2], t3);
              return -1 === n3 ? void 0 : d(de[e2], n3, 1)[0];
            }
            return p(de[e2]);
          }, o2.removeHooks = function(e2) {
            de[e2] = [];
          }, o2.removeAllHooks = function() {
            de = { afterSanitizeAttributes: [], afterSanitizeElements: [], afterSanitizeShadowDOM: [], beforeSanitizeAttributes: [], beforeSanitizeElements: [], beforeSanitizeShadowDOM: [], uponSanitizeAttribute: [], uponSanitizeElement: [], uponSanitizeShadowNode: [] };
          }, o2;
        }();
        return re;
      });
    }
  });
  require_stdin();
})();
/*! @license DOMPurify 3.3.0 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.3.0/LICENSE */
